/*
 * TruthTableFrame.java
 *
 * Created on 16. Januar 2004, 17:38
 */

/**
 *
 * @author  Adrian Imfeld
 */
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.table.*;
import javax.swing.event.*;
import java.util.*;  // Vector
import Tools.*;

public class TruthTableFrame extends javax.swing.JFrame 
{
    private static final Font LogicFont14Bold = Tools.LoadFont(LogicAnalyzer.class.getClassLoader(), "LogicFont.ttf", Font.BOLD, 14);
    
    static final Dimension ScreenResolution = (Dimension)Toolkit.getDefaultToolkit().getScreenSize();
    
    static final int PixelsPerLetter = 12;
    static final int AddToColWidth = 25;
    static final int TableHeaderHeight = 24;
    static final int AddToHeight = 10;
    static final int MaxTableWidth = ScreenResolution.width - 100;
    static final int MaxTableHeight = ScreenResolution.height - 250;
    
    String[][] DATA = null;
    String[] COLHEADS = null;
    int ROWS;
    int COLS;
    
    /** Creates new form TruthTableFrame */
    public TruthTableFrame(SymbolNode n) 
    {
        initComponents();
        jExpressionLabel.setText(n.GetExpression());
        
        // Daten der Tabelle initialisieren
        InitData(n);
        
        // Spaltenmodell für Darstellung erzeugen
        DefaultTableColumnModel cm = CreateTableColumnModel();
        
        // Tabellenmodell für Daten erzeugen
        TableModel tm = CreateAbstractTableModel(); 
        
        // Tabelle erzeugen
        JTable jTable = new JTable(tm, cm);
       
        // Renderer setzen für Zentrierung der Zellwerte
        CenterCellRenderer ccr = new CenterCellRenderer(jTable);
        jTable.setDefaultRenderer(Object.class, ccr);
        
        CenterHeaderRenderer chr = new CenterHeaderRenderer(jTable);
        for (int i=0; i<jTable.getColumnCount(); i++) 
            jTable.getColumnModel().getColumn(i).setHeaderRenderer(chr);

        // Zellselektion ausschalten
        jTable.setCellSelectionEnabled(false);

        // Fenstergrösse einstellen
        jScrollPane1.setPreferredSize(new java.awt.Dimension(Math.min(GetTableWidth(jTable), MaxTableWidth),
                                                            Math.min(GetTableHeight(jTable), MaxTableHeight)));
        
        // Tabelle in die ScrollPane setzen
        jScrollPane1.setViewportView(jTable);

        pack();
    }
    
    private void InitData(SymbolNode n) 
    {
        Vector vsn = new Vector(); // Vector, der die SymbolNodes (Ausdrücke)
        n.ListNode(vsn);            // Zuerst!
        
        COLS = vsn.size();
        ROWS = n.GetRowCount();
                
        Collections.sort(vsn, new SymbolNodeComparator());  // Variablen an den Anfang der Tabelle etc.
        
        COLHEADS = new String[COLS];
        DATA = new String[ROWS][COLS];
        
        for (int i = 0; i < COLS; ++i)       // Columns
        {
            COLHEADS[i] = ((SymbolNode)vsn.get(i)).GetExpression();
            for (int i2 = 0; i2 < ROWS; ++i2)     // Rows
                DATA[i2][i] = ((SymbolNode)vsn.get(i)).Values[i2] ? Symbols.True : Symbols.False;
        }                
    }
    
    private static int GetTableWidth(JTable t)
    {
        return t.getColumnModel().getTotalColumnWidth();
    }
    
    private static int GetTableHeight(JTable t)
    {   // Wie kommt man an die Höhe des Headers?? 
        return t.getRowHeight() * t.getRowCount() + TableHeaderHeight + TableHeaderHeight;
    }

    private TableModel CreateAbstractTableModel()
    {
        return new AbstractTableModel() 
        {
            public int getRowCount() {
                return DATA.length;
            }
            public int getColumnCount() {
                return DATA[0].length;
            }
            public Object getValueAt(int row, int column) {
                return DATA[row][column];
            }
        };
    }
    
    private DefaultTableColumnModel CreateTableColumnModel()
    {    
        DefaultTableColumnModel cm = new DefaultTableColumnModel();
        for (int i = 0; i < COLHEADS.length; ++i) 
        {
            TableColumn col = new TableColumn(i, COLHEADS[i].length() * PixelsPerLetter + AddToColWidth);
            col.setHeaderValue(COLHEADS[i]);
            cm.addColumn(col);
        }
        return cm;
    }
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        jLabel1 = new javax.swing.JLabel();
        jExpressionLabel = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();

        setTitle("Truthtable Viewer");
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                exitForm(evt);
            }
        });
        getContentPane().setLayout(new java.awt.GridBagLayout());

        jLabel1.setFont(LogicFont14Bold);
        jLabel1.setText("Truthtable:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        getContentPane().add(jLabel1, gridBagConstraints);

        jExpressionLabel.setFont(LogicFont14Bold);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        getContentPane().add(jExpressionLabel, gridBagConstraints);

        jScrollPane1.setPreferredSize(new java.awt.Dimension(0, 0));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        getContentPane().add(jScrollPane1, gridBagConstraints);

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    /** Exit the Application */
    private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
        // System.exit(0);
    }//GEN-LAST:event_exitForm
        
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jExpressionLabel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
    
}

// Geklauter Renderer:
class CenterCellRenderer extends JLabel implements TableCellRenderer 
{
    private static final Font LogicFont14Plain = Tools.LoadFont(LogicAnalyzer.class.getClassLoader(), "LogicFont.ttf", Font.PLAIN, 14);

    CenterCellRenderer(JTable table) 
    {
        setHorizontalAlignment(CENTER);
        setFont(LogicFont14Plain);
    }
    
    public Component getTableCellRendererComponent(JTable table, Object value,
    boolean isSelected, boolean hasFocus, int row, int column) 
    {
        setText((value == null) ? "" : value.toString());
        return this;
    }
}
class CenterHeaderRenderer extends CenterCellRenderer
{
    CenterHeaderRenderer(JTable table)
    {
        super(table);
        setBorder(UIManager.getBorder("TableHeader.cellBorder"));
    }
}

